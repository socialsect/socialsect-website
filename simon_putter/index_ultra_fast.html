<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Fast Video Object Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .performance-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid #4facfe;
        }

        .stat-card h4 {
            color: #333;
            margin-bottom: 5px;
        }

        .stat-card .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4facfe;
        }

        .stat-card .trend {
            font-size: 0.8rem;
            margin-top: 5px;
        }

        .stat-card .trend.up {
            color: #28a745;
        }

        .stat-card .trend.down {
            color: #dc3545;
        }

        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .video-section {
            text-align: center;
        }

        .video-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3rem;
        }

        video, canvas {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .results-section {
            margin-top: 30px;
        }

        .detection-results {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .trajectory-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .trajectory-panel h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .arc-classification {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            backdrop-filter: blur(10px);
        }

        .arc-type {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .confidence-bar {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            transition: width 0.3s ease;
        }

        .trajectory-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .center-line-controls {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .center-line-controls h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .center-line-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        .center-line-btn:hover {
            background: #00f2fe;
        }

        .trajectory-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .trajectory-line {
            stroke: #ff6b6b;
            stroke-width: 3;
            fill: none;
            stroke-dasharray: 5,5;
            animation: dash 1s linear infinite;
        }

        .center-line {
            stroke: #4facfe;
            stroke-width: 2;
            stroke-dasharray: 10,5;
        }

        .trajectory-point {
            fill: #ff6b6b;
            r: 4;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }

        .session-controls {
            background: #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .session-controls h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .session-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        .session-btn:hover {
            background: #218838;
        }

        .session-btn.danger {
            background: #dc3545;
        }

        .session-btn.danger:hover {
            background: #c82333;
        }

        .detection-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-left: 4px solid #4facfe;
        }

        .detection-item h4 {
            color: #333;
            margin-bottom: 8px;
        }

        .detection-item p {
            color: #666;
            margin: 5px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .frame-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .frame-counter {
            font-weight: 600;
            color: #333;
        }

        .fps-display {
            color: #666;
        }

        .optimization-panel {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .optimization-panel h4 {
            margin-bottom: 15px;
            color: #1976d2;
        }

        .endpoint-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .endpoint-btn {
            padding: 8px 16px;
            border: 2px solid #4facfe;
            background: white;
            color: #4facfe;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .endpoint-btn.active {
            background: #4facfe;
            color: white;
        }

        .endpoint-btn:hover {
            background: #4facfe;
            color: white;
        }

        .latency-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .latency-indicator.excellent {
            background: #28a745;
        }

        .latency-indicator.good {
            background: #ffc107;
        }

        .latency-indicator.poor {
            background: #dc3545;
        }

        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .performance-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .endpoint-selector {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚡ Ultra-Fast Video Object Detection</h1>
            <p>Maximum performance with minimal latency</p>
        </div>

        <div class="content">
            <div class="upload-section">
                <div class="file-input-wrapper">
                    <input type="file" id="videoInput" class="file-input" accept="video/*">
                    <label for="videoInput" class="file-input-label">
                        📁 Choose Video File
                    </label>
                </div>
                
                <div class="controls">
                    <button id="startBtn" class="btn btn-primary" disabled>▶️ Start Processing</button>
                    <button id="pauseBtn" class="btn btn-secondary" disabled>⏸️ Pause</button>
                    <button id="stopBtn" class="btn btn-secondary" disabled>⏹️ Stop</button>
                    <button id="streamBtn" class="btn btn-success" disabled>🌊 Stream Mode</button>
                </div>

                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>

                <div id="status" class="status" style="display: none;"></div>
            </div>

            <div class="optimization-panel">
                <h4>⚡ Performance Optimization</h4>
                <div class="endpoint-selector">
                    <div class="endpoint-btn active" data-endpoint="detect_fast">
                        <span class="latency-indicator excellent"></span>
                        Ultra-Fast (No Image)
                    </div>
                    <div class="endpoint-btn" data-endpoint="detect">
                        <span class="latency-indicator good"></span>
                        Fast (With Image)
                    </div>
                    <div class="endpoint-btn" data-endpoint="detect_stream">
                        <span class="latency-indicator excellent"></span>
                        Streaming
                    </div>
                </div>
                <p style="color: #666; font-size: 0.9rem;">
                    <strong>Ultra-Fast:</strong> Detections only (~50-100ms) | 
                    <strong>Fast:</strong> Detections + Image (~100-150ms) | 
                    <strong>Streaming:</strong> Real-time streaming (~50-100ms)
                </p>
            </div>

            <div class="performance-stats">
                <div class="stat-card">
                    <h4>Current Latency</h4>
                    <div class="value" id="currentLatency">0ms</div>
                    <div class="trend" id="latencyTrend"></div>
                </div>
                <div class="stat-card">
                    <h4>Average Latency</h4>
                    <div class="value" id="avgLatency">0ms</div>
                    <div class="trend" id="avgTrend"></div>
                </div>
                <div class="stat-card">
                    <h4>Processing FPS</h4>
                    <div class="value" id="processingFPS">0</div>
                    <div class="trend" id="fpsTrend"></div>
                </div>
                <div class="stat-card">
                    <h4>Cache Hit Rate</h4>
                    <div class="value" id="cacheHitRate">0%</div>
                    <div class="trend" id="cacheTrend"></div>
                </div>
            </div>

            <div class="video-container">
                <div class="video-section">
                    <h3>📹 Original Video</h3>
                    <video id="originalVideo" controls style="display: none;"></video>
                    <canvas id="frameCanvas" style="display: none;"></canvas>
                </div>

                <div class="video-section">
                    <h3>🔍 Processed Frames</h3>
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>

            <div class="frame-info">
                <div class="frame-counter">Frame: <span id="currentFrame">0</span> / <span id="totalFramesDisplay">0</span></div>
                <div class="fps-display">Processing Time: <span id="processingTime">0</span>ms</div>
            </div>

            <div class="results-section">
                <h3>🎯 Detection Results</h3>
                <div id="detectionResults" class="detection-results">
                    <p style="text-align: center; color: #666; font-style: italic;">
                        Upload a video and start processing to see detection results here
                    </p>
                </div>
            </div>

            <!-- Trajectory Analysis Panel -->
            <div class="trajectory-panel">
                <h3>📈 Trajectory Analysis</h3>
                <div id="trajectoryAnalysis">
                    <div class="arc-classification">
                        <div class="arc-type">No trajectory data yet</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: 0%"></div>
                        </div>
                        <div style="font-size: 0.9rem; opacity: 0.8;">Upload a video to start trajectory analysis</div>
                        <div id="trajectoryStatus" style="font-size: 0.8rem; opacity: 0.7; margin-top: 5px;">
                            Status: Ready
                        </div>
                    </div>
                </div>
                
                <div class="trajectory-stats" id="trajectoryStats">
                    <div class="stat-item">
                        <div class="stat-value" id="trajectoryCount">0</div>
                        <div class="stat-label">Trajectories</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgSpeed">0.0</div>
                        <div class="stat-label">Avg Speed (m/s)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalDistance">0.0</div>
                        <div class="stat-label">Total Distance (m)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="activeTrajectories">0</div>
                        <div class="stat-label">Active</div>
                    </div>
                </div>
            </div>

            <!-- Center Line Controls -->
            <div class="center-line-controls">
                <h4>🎯 Center Line Reference</h4>
                <button class="center-line-btn" onclick="setAutoCenterLine()">Auto Calculate</button>
                <button class="center-line-btn" onclick="setManualCenterLine()">Set Manually</button>
                <button class="center-line-btn" onclick="clearCenterLine()">Clear</button>
                <div id="centerLineStatus" style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                    No center line set
                </div>
            </div>

            <!-- Session Controls -->
            <div class="session-controls">
                <h4>📊 Session Management</h4>
                <button class="session-btn" onclick="getTrajectorySummary()">View Summary</button>
                <button class="session-btn" onclick="exportTrajectoryData()">Export Data</button>
                <button class="session-btn danger" onclick="clearSession()">Clear Session</button>
                <div id="sessionInfo" style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                    Session ID: <span id="currentSessionId">default</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class UltraFastVideoProcessor {
            constructor() {
                this.video = document.getElementById('originalVideo');
                this.frameCanvas = document.getElementById('frameCanvas');
                this.processedCanvas = document.getElementById('processedCanvas');
                this.frameCtx = this.frameCanvas.getContext('2d');
                this.processedCtx = this.processedCanvas.getContext('2d');
                
                this.isProcessing = false;
                this.isPaused = false;
                this.currentFrameIndex = 0;
                this.totalFrames = 0;
                this.frameRate = 30;
                this.frames = [];
                this.startTime = 0;
                this.frameCount = 0;
                this.currentEndpoint = 'detect_fast';
                this.latencyHistory = [];
                this.performanceStats = {
                    totalRequests: 0,
                    cacheHits: 0,
                    avgLatency: 0,
                    minLatency: Infinity,
                    maxLatency: 0
                };
                
                // Trajectory analysis properties
                this.sessionId = 'session_' + Date.now();
                this.trajectoryData = {
                    activeTrajectories: 0,
                    completedTrajectories: 0,
                    centerLine: null,
                    arcClassifications: []
                };
                this.trajectoryPoints = [];
                this.centerLinePoints = [];
                this.isManualCenterLineMode = false;
                
                this.initializeEventListeners();
                this.startPerformanceMonitoring();
                this.updateSessionDisplay();
            }

            initializeEventListeners() {
                document.getElementById('videoInput').addEventListener('change', (e) => this.handleVideoUpload(e));
                document.getElementById('startBtn').addEventListener('click', () => this.startProcessing());
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopProcessing());
                document.getElementById('streamBtn').addEventListener('click', () => this.startStreaming());
                
                // Endpoint selection
                document.querySelectorAll('.endpoint-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.endpoint-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentEndpoint = e.target.dataset.endpoint;
                        this.showStatus(`Switched to ${e.target.textContent.trim()} mode`, 'info');
                    });
                });
            }

            async startPerformanceMonitoring() {
                setInterval(async () => {
                    try {
                        const response = await fetch('http://localhost:8000/performance');
                        const stats = await response.json();
                        this.updatePerformanceStats(stats);
                    } catch (error) {
                        console.log('Performance monitoring unavailable');
                    }
                }, 20000);
            }

            updatePerformanceStats(stats) {
                this.performanceStats = stats;
                
                document.getElementById('avgLatency').textContent = `${stats.avg_latency_ms}ms`;
                document.getElementById('cacheHitRate').textContent = `${stats.cache_hit_rate}%`;
                
                // Update latency indicator
                const latencyIndicator = document.querySelector('.endpoint-btn.active .latency-indicator');
                if (stats.avg_latency_ms < 100) {
                    latencyIndicator.className = 'latency-indicator excellent';
                } else if (stats.avg_latency_ms < 200) {
                    latencyIndicator.className = 'latency-indicator good';
                } else {
                    latencyIndicator.className = 'latency-indicator poor';
                }
            }

            handleVideoUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const url = URL.createObjectURL(file);
                this.video.src = url;
                this.video.style.display = 'block';
                
                this.video.addEventListener('loadedmetadata', () => {
                    this.setupCanvas();
                    this.frameRate = this.video.videoWidth > 0 ? 30 : 30;
                    this.totalFrames = Math.floor(this.video.duration * this.frameRate);
                    document.getElementById('totalFramesDisplay').textContent = this.totalFrames;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('streamBtn').disabled = false;
                    this.showStatus('Video loaded successfully! Ready to process.', 'success');
                });
            }

            setupCanvas() {
                const width = this.video.videoWidth;
                const height = this.video.videoHeight;
                
                this.frameCanvas.width = width;
                this.frameCanvas.height = height;
                this.processedCanvas.width = width;
                this.processedCanvas.height = height;
            }

            async startProcessing() {
                if (this.isProcessing) return;
                
                this.isProcessing = true;
                this.isPaused = false;
                this.currentFrameIndex = 0;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.latencyHistory = [];
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('streamBtn').disabled = true;
                
                this.showStatus(`Processing with ${this.currentEndpoint} endpoint...`, 'info');
                this.processFrames();
            }

            async startStreaming() {
                if (this.isProcessing) return;
                
                this.isProcessing = true;
                this.isPaused = false;
                this.currentFrameIndex = 0;
                this.startTime = Date.now();
                this.frameCount = 0;
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('streamBtn').disabled = true;
                
                this.showStatus('Starting streaming mode...', 'info');
                this.processFramesStreaming();
            }

            async processFrames() {
                while (this.isProcessing && this.currentFrameIndex < this.totalFrames && !this.isPaused) {
                    const frameStartTime = Date.now();
                    
                    const frame = await this.extractFrame(this.currentFrameIndex);
                    const blob = await this.canvasToBlob(frame);
                    
                    try {
                        // Use detect endpoint for images, detect_fast for speed
                        const endpoint = this.currentEndpoint === 'detect_fast' ? 'detect' : this.currentEndpoint;
                        const result = await this.sendFrameToBackend(blob, endpoint);
                        const frameEndTime = Date.now();
                        const latency = frameEndTime - frameStartTime;
                        
                        this.updateLatencyStats(latency);
                        this.displayResults(result);
                        
                        if (result.annotated_image) {
                            this.displayProcessedFrame(result.annotated_image);
                        } else {
                            console.log('No annotated image in response');
                        }
                        
                    } catch (error) {
                        console.error('Frame processing error:', error);
                        this.showStatus(`Error processing frame: ${error.message}`, 'error');
                    }
                    
                    this.currentFrameIndex++;
                    this.frameCount++;
                    this.updateProgress();
                    this.updateFrameCounter();
                    this.updateStats();
                    
                    // Adaptive delay based on latency
                    const delay = Math.max(0, 100 - (Date.now() - frameStartTime));
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                
                if (this.currentFrameIndex >= this.totalFrames) {
                    this.stopProcessing();
                    this.showStatus('Processing completed!', 'success');
                }
            }

            async processFramesStreaming() {
                while (this.isProcessing && this.currentFrameIndex < this.totalFrames && !this.isPaused) {
                    const frame = await this.extractFrame(this.currentFrameIndex);
                    const blob = await this.canvasToBlob(frame);
                    
                    try {
                        const response = await fetch('http://localhost:8000/detect_stream', {
                            method: 'POST',
                            body: this.createFormData(blob, 'streaming')
                        });
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.slice(6));
                                        if (data.detections) {
                                            this.displayResults({ detections: data.detections });
                                        }
                                        if (data.image) {
                                            this.displayProcessedFrame(data.image);
                                        }
                                    } catch (e) {
                                        // Ignore parsing errors
                                    }
                                }
                            }
                        }
                        
                    } catch (error) {
                        console.error('Streaming error:', error);
                    }
                    
                    this.currentFrameIndex++;
                    this.frameCount++;
                    this.updateProgress();
                    this.updateFrameCounter();
                }
                
                if (this.currentFrameIndex >= this.totalFrames) {
                    this.stopProcessing();
                    this.showStatus('Streaming completed!', 'success');
                }
            }

            async extractFrame(frameIndex) {
                const time = frameIndex / this.frameRate;
                this.video.currentTime = time;
                
                return new Promise((resolve) => {
                    const onSeeked = () => {
                        this.video.removeEventListener('seeked', onSeeked);
                        this.frameCtx.drawImage(this.video, 0, 0, this.frameCanvas.width, this.frameCanvas.height);
                        resolve(this.frameCanvas);
                    };
                    this.video.addEventListener('seeked', onSeeked);
                });
            }

            async sendFrameToBackend(blob, endpoint) {
                const formData = this.createFormData(blob, 'video_processing');
                
                const response = await fetch(`http://localhost:8000/${endpoint}`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('API Response:', result); // Debug log
                return result;
            }

            createFormData(blob, sessionId) {
                const formData = new FormData();
                formData.append('file', blob, 'frame.jpg');
                formData.append('session_id', sessionId);
                return formData;
            }

            updateLatencyStats(latency) {
                this.latencyHistory.push(latency);
                if (this.latencyHistory.length > 10) {
                    this.latencyHistory.shift();
                }
                
                document.getElementById('currentLatency').textContent = `${latency}ms`;
                document.getElementById('processingTime').textContent = latency;
                
                // Update trend indicators
                this.updateTrendIndicator('latencyTrend', latency, this.latencyHistory);
            }

            updateTrendIndicator(elementId, current, history) {
                if (history.length < 2) return;
                
                const previous = history[history.length - 2];
                const trend = current < previous ? 'up' : 'down';
                const element = document.getElementById(elementId);
                element.className = `trend ${trend}`;
                element.textContent = current < previous ? '↓' : '↑';
            }

            displayResults(result) {
                if (!result.detections) return;
                
                const resultsContainer = document.getElementById('detectionResults');
                
                if (result.detections.length === 0) {
                    resultsContainer.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">No objects detected</p>';
                    return;
                }
                
                let html = '';
                result.detections.forEach((detection, index) => {
                    html += `
                        <div class="detection-item">
                            <h4>Detection ${index + 1}</h4>
                            <p><strong>Class:</strong> ${detection.class}</p>
                            <p><strong>Confidence:</strong> ${(detection.confidence * 100).toFixed(1)}%</p>
                            <p><strong>Bounding Box:</strong> [${detection.bbox.map(b => b.toFixed(1)).join(', ')}]</p>
                        </div>
                    `;
                });
                
                resultsContainer.innerHTML = html;
                
                // Analyze trajectory for detected objects
                console.log('Calling trajectory analysis with detections:', result.detections);
                this.analyzeTrajectory(result.detections);
            }

            displayProcessedFrame(imageDataUri) {
                console.log('Displaying image:', imageDataUri ? 'Image data received' : 'No image data');
                
                if (!imageDataUri) {
                    console.log('No image data to display');
                    return;
                }
                
                const img = new Image();
                img.onload = () => {
                    console.log('Image loaded successfully');
                    this.processedCtx.clearRect(0, 0, this.processedCanvas.width, this.processedCanvas.height);
                    this.processedCtx.drawImage(img, 0, 0, this.processedCanvas.width, this.processedCanvas.height);
                };
                img.onerror = (e) => {
                    console.error('Error loading image:', e);
                };
                img.src = imageDataUri;
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                const pauseBtn = document.getElementById('pauseBtn');
                
                if (this.isPaused) {
                    pauseBtn.textContent = '▶️ Resume';
                    this.showStatus('Processing paused', 'info');
                } else {
                    pauseBtn.textContent = '⏸️ Pause';
                    this.showStatus('Resuming processing...', 'info');
                    if (this.currentEndpoint === 'detect_stream') {
                        this.processFramesStreaming();
                    } else {
                        this.processFrames();
                    }
                }
            }

            stopProcessing() {
                this.isProcessing = false;
                this.isPaused = false;
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('streamBtn').disabled = false;
                document.getElementById('pauseBtn').textContent = '⏸️ Pause';
                
                this.showStatus('Processing stopped', 'info');
            }

            updateProgress() {
                const progress = (this.currentFrameIndex / this.totalFrames) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
            }

            updateFrameCounter() {
                document.getElementById('currentFrame').textContent = this.currentFrameIndex;
            }

            updateStats() {
                const elapsed = (Date.now() - this.startTime) / 1000;
                const fps = this.frameCount / elapsed;
                document.getElementById('processingFPS').textContent = fps.toFixed(1);
            }

            showStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
                status.style.display = 'block';
                
                if (type === 'success') {
                    setTimeout(() => {
                        status.style.display = 'none';
                    }, 3000);
                }
            }

            canvasToBlob(canvas) {
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.6); // Lower quality for speed
                });
            }

            // ===== TRAJECTORY ANALYSIS METHODS =====

            async analyzeTrajectory(detections) {
                try {
                    console.log('Starting trajectory analysis...');
                    console.log('Session ID:', this.sessionId);
                    console.log('Frame index:', this.currentFrameIndex);
                    console.log('Detections:', detections);
                    
                    // Update status
                    this.updateTrajectoryStatus('Analyzing...');
                    
                    const response = await fetch('http://localhost:8000/analyze_trajectory', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            detections: detections,
                            frame_index: this.currentFrameIndex,
                            timestamp: Date.now() / 1000,
                            session_id: this.sessionId
                        })
                    });

                    console.log('Trajectory analysis response status:', response.status);
                    const result = await response.json();
                    console.log('Trajectory analysis result:', result);
                    
                    if (result.success) {
                        this.updateTrajectoryDisplay(result);
                        this.updateTrajectoryStats(result);
                        this.updateTrajectoryStatus('Active');
                    } else {
                        console.error('Trajectory analysis failed:', result.error);
                        this.updateTrajectoryStatus('Error: ' + result.error);
                    }
                } catch (error) {
                    console.error('Trajectory analysis error:', error);
                    this.updateTrajectoryStatus('Error: ' + error.message);
                }
            }

            updateTrajectoryDisplay(result) {
                console.log('Updating trajectory display with result:', result);
                const trajectoryContainer = document.getElementById('trajectoryAnalysis');
                
                if (result.arc_classifications && result.arc_classifications.length > 0) {
                    console.log('Found arc classifications:', result.arc_classifications);
                    const latestClassification = result.arc_classifications[result.arc_classifications.length - 1];
                    console.log('Latest classification:', latestClassification);
                    
                    const arcTypeElement = trajectoryContainer.querySelector('.arc-type');
                    const confidenceFill = trajectoryContainer.querySelector('.confidence-fill');
                    const reasoningElement = trajectoryContainer.querySelector('div[style*="font-size: 0.9rem"]');
                    
                    if (arcTypeElement) {
                        arcTypeElement.textContent = this.formatArcType(latestClassification.arc_type);
                        console.log('Updated arc type to:', this.formatArcType(latestClassification.arc_type));
                    }
                    
                    if (confidenceFill) {
                        const confidencePercent = Math.round(latestClassification.confidence * 100);
                        confidenceFill.style.width = `${confidencePercent}%`;
                        console.log('Updated confidence to:', confidencePercent + '%');
                    }
                    
                    if (reasoningElement) {
                        reasoningElement.textContent = latestClassification.reasoning;
                        console.log('Updated reasoning to:', latestClassification.reasoning);
                    }
                } else {
                    console.log('No arc classifications found in result');
                    // Update display to show that we're building trajectories
                    const arcTypeElement = trajectoryContainer.querySelector('.arc-type');
                    const reasoningElement = trajectoryContainer.querySelector('div[style*="font-size: 0.9rem"]');
                    const confidenceFill = trajectoryContainer.querySelector('.confidence-fill');
                    
                    if (arcTypeElement) {
                        arcTypeElement.textContent = 'Building trajectory...';
                    }
                    if (reasoningElement) {
                        reasoningElement.textContent = `Frame ${this.currentFrameIndex} - Collecting trajectory points (need 5+ points for classification)`;
                    }
                    if (confidenceFill) {
                        confidenceFill.style.width = '0%';
                    }
                }
            }

            updateTrajectoryStats(result) {
                console.log('Updating trajectory stats with result:', result);
                if (result.analysis_result) {
                    console.log('Analysis result:', result.analysis_result);
                    document.getElementById('activeTrajectories').textContent = result.analysis_result.active_trajectories || 0;
                    document.getElementById('trajectoryCount').textContent = result.analysis_result.completed_trajectories || 0;
                    console.log('Updated stats - Active:', result.analysis_result.active_trajectories, 'Completed:', result.analysis_result.completed_trajectories);
                }
                
                if (result.center_line) {
                    console.log('Center line updated:', result.center_line);
                    this.trajectoryData.centerLine = result.center_line;
                    this.updateCenterLineStatus();
                }
            }

            formatArcType(arcType) {
                const arcTypeMap = {
                    'straight': 'Straight Arc',
                    'slight_arc': 'Slight Arc',
                    'strong_arc': 'Strong Arc',
                    'slight_to_straight_arc': 'Slight → Straight Arc',
                    'straight_to_slight_arc': 'Straight → Slight Arc',
                    'strong_arc_to_straight_arc': 'Strong → Straight Arc',
                    'straight_arc_to_strong_arc': 'Straight → Strong Arc'
                };
                return arcTypeMap[arcType] || arcType;
            }

            async setAutoCenterLine() {
                try {
                    const response = await fetch('http://localhost:8000/get_trajectory_summary/' + this.sessionId);
                    const result = await response.json();
                    
                    if (result.success && result.summary.center_line) {
                        this.trajectoryData.centerLine = result.summary.center_line;
                        this.updateCenterLineStatus();
                        this.showStatus('Center line calculated automatically', 'success');
                    } else {
                        this.showStatus('No trajectory data available for center line calculation', 'warning');
                    }
                } catch (error) {
                    console.error('Auto center line error:', error);
                    this.showStatus('Error calculating center line', 'error');
                }
            }

            setManualCenterLine() {
                this.isManualCenterLineMode = true;
                this.showStatus('Click and drag on the video to set center line', 'info');
                
                // Add click event listeners for manual center line setting
                this.frameCanvas.addEventListener('mousedown', this.handleCenterLineStart.bind(this));
                this.frameCanvas.addEventListener('mousemove', this.handleCenterLineMove.bind(this));
                this.frameCanvas.addEventListener('mouseup', this.handleCenterLineEnd.bind(this));
            }

            handleCenterLineStart(e) {
                if (!this.isManualCenterLineMode) return;
                
                const rect = this.frameCanvas.getBoundingClientRect();
                this.centerLinePoints = [{
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                }];
            }

            handleCenterLineMove(e) {
                if (!this.isManualCenterLineMode || this.centerLinePoints.length === 0) return;
                
                const rect = this.frameCanvas.getBoundingClientRect();
                this.centerLinePoints[1] = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                this.drawTemporaryCenterLine();
            }

            handleCenterLineEnd(e) {
                if (!this.isManualCenterLineMode || this.centerLinePoints.length < 2) return;
                
                this.saveManualCenterLine();
                this.isManualCenterLineMode = false;
                
                // Remove event listeners
                this.frameCanvas.removeEventListener('mousedown', this.handleCenterLineStart);
                this.frameCanvas.removeEventListener('mousemove', this.handleCenterLineMove);
                this.frameCanvas.removeEventListener('mouseup', this.handleCenterLineEnd);
            }

            async saveManualCenterLine() {
                try {
                    const response = await fetch('http://localhost:8000/set_center_line', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            start_x: this.centerLinePoints[0].x,
                            start_y: this.centerLinePoints[0].y,
                            end_x: this.centerLinePoints[1].x,
                            end_y: this.centerLinePoints[1].y,
                            session_id: this.sessionId
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.trajectoryData.centerLine = result.center_line;
                        this.updateCenterLineStatus();
                        this.showStatus('Center line set manually', 'success');
                    }
                } catch (error) {
                    console.error('Manual center line error:', error);
                    this.showStatus('Error setting center line', 'error');
                }
            }

            clearCenterLine() {
                this.trajectoryData.centerLine = null;
                this.updateCenterLineStatus();
                this.showStatus('Center line cleared', 'info');
            }

            updateCenterLineStatus() {
                const statusElement = document.getElementById('centerLineStatus');
                if (this.trajectoryData.centerLine) {
                    statusElement.innerHTML = `Center line set: (${this.trajectoryData.centerLine.start_x.toFixed(1)}, ${this.trajectoryData.centerLine.start_y.toFixed(1)}) → (${this.trajectoryData.centerLine.end_x.toFixed(1)}, ${this.trajectoryData.centerLine.end_y.toFixed(1)})`;
                    statusElement.style.color = '#28a745';
                } else {
                    statusElement.textContent = 'No center line set';
                    statusElement.style.color = '#666';
                }
            }

            async getTrajectorySummary() {
                try {
                    const response = await fetch('http://localhost:8000/get_trajectory_summary/' + this.sessionId);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.displayTrajectorySummary(result);
                    } else {
                        this.showStatus('No trajectory data available', 'warning');
                    }
                } catch (error) {
                    console.error('Trajectory summary error:', error);
                    this.showStatus('Error getting trajectory summary', 'error');
                }
            }

            displayTrajectorySummary(summary) {
                const summaryText = `
                    Total Trajectories: ${summary.summary.total_trajectories}
                    Total Distance: ${summary.summary.total_distance.toFixed(2)}m
                    Average Speed: ${summary.summary.average_speed.toFixed(2)} m/s
                `;
                
                alert('Trajectory Summary:\n' + summaryText);
            }

            async exportTrajectoryData() {
                try {
                    const response = await fetch('http://localhost:8000/get_trajectory_summary/' + this.sessionId);
                    const result = await response.json();
                    
                    if (result.success) {
                        const dataStr = JSON.stringify(result, null, 2);
                        const dataBlob = new Blob([dataStr], {type: 'application/json'});
                        const url = URL.createObjectURL(dataBlob);
                        
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `trajectory_data_${this.sessionId}.json`;
                        link.click();
                        
                        URL.revokeObjectURL(url);
                        this.showStatus('Trajectory data exported', 'success');
                    }
                } catch (error) {
                    console.error('Export error:', error);
                    this.showStatus('Error exporting data', 'error');
                }
            }

            async clearSession() {
                try {
                    const response = await fetch('http://localhost:8000/clear_trajectory_session/' + this.sessionId, {
                        method: 'DELETE'
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        this.trajectoryData = {
                            activeTrajectories: 0,
                            completedTrajectories: 0,
                            centerLine: null,
                            arcClassifications: []
                        };
                        this.updateTrajectoryDisplay({ arc_classifications: [] });
                        this.updateTrajectoryStats({ analysis_result: { active_trajectories: 0, completed_trajectories: 0 } });
                        this.updateCenterLineStatus();
                        this.showStatus('Session cleared', 'success');
                    }
                } catch (error) {
                    console.error('Clear session error:', error);
                    this.showStatus('Error clearing session', 'error');
                }
            }

            drawTemporaryCenterLine() {
                // This would draw a temporary center line on the canvas
                // Implementation depends on your specific needs
            }

            updateSessionDisplay() {
                const sessionElement = document.getElementById('currentSessionId');
                if (sessionElement) {
                    sessionElement.textContent = this.sessionId;
                }
            }

            updateTrajectoryStatus(status) {
                const statusElement = document.getElementById('trajectoryStatus');
                if (statusElement) {
                    statusElement.textContent = 'Status: ' + status;
                }
            }

        }

        // Global functions for button handlers
        let videoProcessor;

        function setAutoCenterLine() {
            if (videoProcessor) {
                videoProcessor.setAutoCenterLine();
            }
        }

        function setManualCenterLine() {
            if (videoProcessor) {
                videoProcessor.setManualCenterLine();
            }
        }

        function clearCenterLine() {
            if (videoProcessor) {
                videoProcessor.clearCenterLine();
            }
        }

        function getTrajectorySummary() {
            if (videoProcessor) {
                videoProcessor.getTrajectorySummary();
            }
        }

        function exportTrajectoryData() {
            if (videoProcessor) {
                videoProcessor.exportTrajectoryData();
            }
        }

        function clearSession() {
            if (videoProcessor) {
                videoProcessor.clearSession();
            }
        }

        // Initialize the ultra-fast video processor when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            videoProcessor = new UltraFastVideoProcessor();
        });
    </script>
</body>
</html>
